{"version":3,"sources":["ng://@ksakira10/ngx-via-cep/lib/ngx-via-cep.variables.ts","ng://@ksakira10/ngx-via-cep/lib/ngx-via-cep.configuration.ts","ng://@ksakira10/ngx-via-cep/lib/ngx-via-cep.service.ts","ng://@ksakira10/ngx-via-cep/lib/ngx-via-cep.module.ts"],"names":["BASE_PATH","InjectionToken","NgxViaCepConfiguration","configurationParameters","this","apiKeys","username","password","accessToken","basePath","withCredentials","prototype","selectHeaderContentType","contentTypes","_this","length","undefined","type","find","x","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","NgxViaCepService","http","configuration","defaultHeaders","HttpHeaders","urlFetchByCEP","cep","urlFetchByAddressSP","address","state","city","encodeURIComponent","fetchByCEP","subject","Subject","replace","get","error","HttpErrorResponse","status","statusText","code","message","asObservable","fetchByAddressSaoPaulo","fetchByAddress","Injectable","HttpClient","Optional","Inject","args","decorators","NgxViaCepModule","parentModule","Error","forRoot","configurationFactory","ngModule","providers","provide","useFactory","NgModule","declarations","imports","exports","SkipSelf","csv","tsv","ssv","pipes"],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","export interface NgxViaCepConfigurationParameters {\n  apiKeys?: {[ key: string ]: string};\n  username?: string;\n  password?: string;\n  accessToken?: string | (() => string);\n  basePath?: string;\n  withCredentials?: boolean;\n}\n\nexport class NgxViaCepConfiguration {\n  apiKeys?: {[ key: string ]: string};\n  username?: string;\n  password?: string;\n  accessToken?: string | (() => string);\n  basePath?: string;\n  withCredentials?: boolean;\n\n  constructor(configurationParameters: NgxViaCepConfigurationParameters = {}) {\n      this.apiKeys = configurationParameters.apiKeys;\n      this.username = configurationParameters.username;\n      this.password = configurationParameters.password;\n      this.accessToken = configurationParameters.accessToken;\n      this.basePath = configurationParameters.basePath;\n      this.withCredentials = configurationParameters.withCredentials;\n  }\n\n  /**\n   * Select the correct content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param contentTypes - the array of content types that are available for selection\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  public selectHeaderContentType (contentTypes: string[]): string | undefined {\n      if (contentTypes.length == 0) {\n          return undefined;\n      }\n\n      let type = contentTypes.find(x => this.isJsonMime(x));\n      if (type === undefined) {\n          return contentTypes[0];\n      }\n      return type;\n  }\n\n  /**\n   * Select the correct accept content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param accepts - the array of content types that are available for selection.\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  public selectHeaderAccept(accepts: string[]): string | undefined {\n      if (accepts.length == 0) {\n          return undefined;\n      }\n\n      let type = accepts.find(x => this.isJsonMime(x));\n      if (type === undefined) {\n          return accepts[0];\n      }\n      return type;\n  }\n\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  public isJsonMime(mime: string): boolean {\n      const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n      return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n  }\n}\n","import {\n  HttpClient,\n  HttpErrorResponse,\n  HttpHeaders\n} from '@angular/common/http';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { NgxViaCepConfiguration } from './ngx-via-cep.configuration';\nimport { BASE_PATH } from './ngx-via-cep.variables';\n\n@Injectable()\nexport class NgxViaCepService {\n  protected basePath = 'https://viacep.com.br/ws';\n  public defaultHeaders = new HttpHeaders();\n  public configuration = new NgxViaCepConfiguration();\n  private readonly urlFetchByCEP = (cep: string) =>\n    `${this.basePath}/${cep}/json/`;\n  private readonly urlFetchByAddressSP = (\n    address: string,\n    state: string = 'SP',\n    city: string = 'SÃ£o Paulo'\n  ) =>\n    `${this.basePath}/${encodeURIComponent(state)}/${encodeURIComponent(\n      city\n    )}/${encodeURIComponent(address)}/json/`;\n\n  constructor(\n    protected http: HttpClient,\n    @Optional() @Inject(BASE_PATH) basePath: string,\n    @Optional() configuration: NgxViaCepConfiguration\n  ) {\n    if (basePath) {\n      this.basePath = basePath;\n    }\n    if (configuration) {\n      this.configuration = configuration;\n      this.basePath = basePath || configuration.basePath || this.basePath;\n    }\n  }\n\n  public fetchByCEP = (cep: string): Observable<any> => {\n    const subject = new Subject<HttpErrorResponse>();\n    cep = cep.replace(/[!@#$%^&*a-zA-Z.-]/gi, '');\n\n    if (/\\d{8}/.test(cep)) {\n      return this.http.get(this.urlFetchByCEP(cep));\n    }\n\n    subject.error(\n      new HttpErrorResponse({\n        status: 412,\n        statusText: 'Precondition failed',\n        error: { code: 1, message: 'length must be equals 8' }\n      })\n    );\n    return subject.asObservable();\n  };\n\n  public fetchByAddressSaoPaulo = (address: string): Observable<any> => {\n    return this.http.get(this.urlFetchByAddressSP(address));\n  };\n\n  public fetchByAddress = (\n    state: string,\n    city: string,\n    address: string\n  ): Observable<any> => {\n    return this.http.get(this.urlFetchByAddressSP(address, state, city));\n  };\n}\n","import { HttpClient } from '@angular/common/http';\nimport { ModuleWithProviders, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { NgxViaCepConfiguration } from './ngx-via-cep.configuration';\nimport { NgxViaCepService } from './ngx-via-cep.service';\n\n@NgModule({\n  declarations: [],\n  imports: [],\n  exports: [],\n  providers: [NgxViaCepService]\n})\nexport class NgxViaCepModule {\n  public static forRoot(\n    configurationFactory: () => NgxViaCepConfiguration\n  ): ModuleWithProviders {\n    return {\n      ngModule: NgxViaCepModule,\n      providers: [\n        { provide: NgxViaCepConfiguration, useFactory: configurationFactory }\n      ]\n    };\n  }\n\n  constructor(\n    @Optional() @SkipSelf() parentModule: NgxViaCepModule,\n    @Optional() http: HttpClient\n  ) {\n    if (parentModule) {\n      throw new Error(\n        'NgxViaCepModule is already loaded. Import in your base AppModule only.'\n      );\n    }\n    if (!http) {\n      throw new Error(\n        'You need to import the HttpClientModule in your AppModule! \\n' +\n          'See also https://github.com/angular/angular/issues/20575'\n      );\n    }\n  }\n}\n"]}